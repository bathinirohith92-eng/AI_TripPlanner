# travel_planner_graph.py (UPDATED)
import json
import uuid
from planner import get_structured_trip_details
from planner import  run_step2
from planner import  process_spots
from planner import  optimize_day_plan
from planner import  format_itinerary_with_llm
from planner import  run_itinerary_pipeline
from typing import TypedDict, Annotated, List, Literal, Any, Dict
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.types import Command
from pydantic import BaseModel, Field
import os
from dotenv import load_dotenv
import asyncio
import aiohttp
import random
import json
from bus__ import get_bus_routes_json
from accomdation import find_best_nearby_hotels
# --- IMPORTS FOR AMADEUS API INTEGRATION ---
import requests
from datetime import date, timedelta
import re  # For simple date/time/location parsing from user query

# ------------------------------------------

# Load environment variables
load_dotenv()

# Initialize LLM
llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash", temperature=0.0)

# --- CONFIGURATION: Amadeus API ---
API_KEY = os.environ.get('AMADEUS_API_KEY')
API_SECRET = os.environ.get('AMADEUS_API_SECRET')
USD_TO_INR_RATE = 88.23

TOKEN_URL = 'https://test.api.amadeus.com/v1/security/oauth2/token'
FLIGHT_SEARCH_URL = 'https://test.api.amadeus.com/v2/shopping/flight-offers'
LOCATION_SEARCH_URL = 'https://test.api.amadeus.com/v1/reference-data/locations'


# --- 1. Pydantic Schemas ---

class DayItinerarySchema(BaseModel):
    """A single activity entry in the daily itinerary."""
    time: str = Field(description="Time of the day (e.g., 'Morning', '10:00 AM').")
    activity: str = Field(description="Detailed activity description.")
    location: str = Field(description="Location or place name.")


class TravelPlanSchema(BaseModel):
    """A single complete travel plan."""
    id: str = Field(description="Unique ID for this plan (will be generated by Python).")
    title: str = Field(description="A catchy, short title for the plan.")
    short_desc: str = Field(description="A concise, 15-word description of the plan's focus.")
    duration: str = Field(description="The length of the trip (e.g., '5 Days / 4 Nights').")
    budget: str = Field(description="The estimated total cost (e.g., 'â‚¹25,000' or 'Moderate').")
    highlights: List[str] = Field(description="3 unique selling points or key attractions of this itinerary.")
    days: List[DayItinerarySchema] = Field(description="A detailed, day-by-day itinerary of activities.")


class Itineraries(BaseModel):
    """The root object containing exactly three travel plans."""
    plans: List[TravelPlanSchema] = Field(description="A list containing exactly three distinct travel plans.")


# --- NEW: Flight Data Schemas ---
class FlightOptionSchema(BaseModel):
    """Structured data for a single flight option."""
    id: str = Field(description="Unique ID for the flight option.")
    carrier: str = Field(description="Airline name or code.")
    flight_number: str = Field(description="Full flight code (e.g., AA123).")
    departure_time: str = Field(description="Departure time (HH:MM).")
    arrival_time: str = Field(description="Arrival time (HH:MM).")
    origin_iata: str = Field(description="Departure airport IATA code.")
    destination_iata: str = Field(description="Arrival airport IATA code.")
    duration: str = Field(description="Total flight duration (e.g., 1H 15M).")
    price_inr: float = Field(description="Total price in Indian Rupees (INR).")
    is_direct: bool = Field(description="True if the flight is direct.")


class FlightOptions(BaseModel):
    """The root object containing flight results."""
    flight_options: List[FlightOptionSchema] = Field(description="A list of the top 5 flight options.")


# --- 2. LangGraph State Definition ---

class State(TypedDict):
    messages: Annotated[list, add_messages]
    user_query: str
    itinerary_plans: List[Dict[str, Any]]
    flight_data: List[Dict[str, Any]]  # NEW: To store flight options
    selected_plan: Dict[str, Any]
    travel_bookings: Dict[str, Any]
    current_agent: str
    execution_status: str
    # NEW: Store extracted booking parameters
    booking_params: Dict[str, Any]
    acomdation:Dict[str,Any]


# --- 3. AMADEUS API HELPER FUNCTIONS (Integrated) ---

def get_amadeus_token(client_id, client_secret):
    """Obtains the OAuth2 access token from Amadeus."""
    try:
        token_headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        token_data = {'grant_type': 'client_credentials', 'client_id': client_id, 'client_secret': client_secret}
        token_response = requests.post(TOKEN_URL, headers=token_headers, data=token_data)
        token_response.raise_for_status()
        return token_response.json().get('access_token')
    except requests.exceptions.RequestException as e:
        print(f"âŒ Error getting access token: {e}")
        return None


def get_iata_code_for_city(access_token, city_name):
    """Uses the Amadeus Location API to find the IATA code for a given city name."""
    if not access_token: return None
    iata_headers = {'Authorization': f'Bearer {access_token}'}
    iata_params = {
        'keyword': city_name,
        'subType': 'CITY,AIRPORT',
        'page[limit]': 1,
        'view': 'FULL'
    }
    try:
        iata_response = requests.get(LOCATION_SEARCH_URL, headers=iata_headers, params=iata_params)
        iata_response.raise_for_status()
        data = iata_response.json().get('data')
        return data[0].get('iataCode') if data and len(data) > 0 else None
    except requests.exceptions.RequestException as e:
        print(f"âŒ Error during IATA code lookup for {city_name}: {e}")
        return None


def parse_booking_query(query: str) -> Dict[str, Any]:
    """Uses simple regex and heuristics to extract origin, destination, and date."""
    params = {}

    # Simple regex for city names (look for capitalized words near 'from' and 'to')
    # This is a highly simplified parser; a real solution would use a specialized LLM tool for extraction.
    cities = re.findall(r'(?:from|to|for)\s+([A-Z][a-z]+)', query, re.IGNORECASE)

    # Heuristic: Simple pattern matching for "city A to city B"
    match = re.search(r'from\s+([A-Za-z]+)\s+to\s+([A-Za-z]+)', query, re.IGNORECASE)
    if match:
        params['origin'] = match.group(1)
        params['destination'] = match.group(2)
    elif len(cities) >= 2:
        # Fallback to the first two capitalized words after prepositions
        params['origin'] = cities[0]
        params['destination'] = cities[1]

    # Date extraction (YYYY-MM-DD or simple tomorrow/next week logic)
    tomorrow = (date.today() + timedelta(days=1)).strftime('%Y-%m-%d')
    if 'tomorrow' in query.lower():
        params['date'] = tomorrow
    else:
        # Simplistic date detection (e.g., 'on 29 october 2025')
        date_match = re.search(r'on\s+(\d{1,2}\s+[A-Za-z]+\s+\d{4})', query, re.IGNORECASE)
        if date_match:
            try:
                # Attempt to parse the date string (requires careful formatting)
                # We'll default to tomorrow for simplicity if exact date parsing is complex
                params['date'] = tomorrow  # Placeholder: Real parsing is complex
            except:
                params['date'] = tomorrow
        else:
            params['date'] = tomorrow  # Default to tomorrow

    params['adults'] = 1  # Default

    return params


# --- 4. LANGGRAPH NODES (AGENTS) ---

def initialagent(state: State) -> Command[Literal["Supervisor"]]:
    """Sets the initial user query, parses booking params, and routes to the Supervisor."""
    user_query = state["messages"][-1].content

    # NEW: Pre-parse the booking parameters
    booking_params = parse_booking_query(user_query)

    ai_msg = AIMessage(content=json.dumps({"initial_agent": f"Processing query: {user_query}"}))

    # Pass parsed params to the state
    return Command(goto="Supervisor",
                   update={"messages": [ai_msg], "user_query": user_query, "booking_params": booking_params})


def Supervisor(state: State) -> Command[Literal["Iterationagent", "FlightBookingagent", "GeneralChatagent","BusBookingAgent", "AccomodationAgent", "END"]]:
    # ... (Supervisor logic remains the same, but the FlightBookingagent description is more specific)

    messages = state["messages"]

    member_dict = {
        "Iterationagent": 'This agent is used to make or create an itinerary. Use this if the user asks for a plan, itinerary, or trip suggestion.',
        'FlightBookingagent': 'Specialized agent to **handle flight/train/bus booking queries**, transportation arrangements, and travel logistics. Use this if the user asks to **book, find options, or finalize a flight/trip** from one city to another.',
        'GeneralChatagent': 'Use this for any general greeting, thanks, or simple non-planning, non-booking queries.',
        "BusBookingAgent": 'Specialized agent to **handle bus route search and booking queries**. Use this specifically if the user asks to **book or find options for a BUS** trip from one city to another.',
        "AccomodationAgent": 'Specialized agent to research, recommend, and facilitate the booking of hotels and temporary stays (resorts, hostels, etc.) based on a target location. Use this if the user asks to find, search, or book accommodation or lodging options.'
    }

    # ... (rest of Supervisor code remains the same)

    worker_info_lines = []
    for member, description in member_dict.items():
        worker_info_lines.append(f"worker:{member}\nDescription:{description}")
    worker_info_lines.append(
        "worker:END \n Description:If the user query is complete or requires no further action from the agents.")
    worker_info = "\n\n".join(worker_info_lines)

    class Router(TypedDict):
        next: Annotated[
            Literal[
                "Iterationagent", "FlightBookingagent", "GeneralChatagent", "BusBookingAgent", "AccomodationAgent", "END"], "worker agent to route to next or route to END"]
        reasoning: Annotated[str, "Support proper reasoning for routing to the worker"]

    prompt = f"""
        You are a supervisor Agent orchestrating a travel planning workflow.
        Based on the user's last message or overall goal, decide which agent needs to be invoked next.

        Available Agents:
        {worker_info}

        Based on the current chat history (especially the user's latest query), what is the next logical step?
        """

    m1 = [
        SystemMessage(content=prompt),
        HumanMessage(content=f"""
The user's last message: {state["user_query"]}
""")
    ]

    try:
        result = llm.with_structured_output(Router).invoke(m1)
    except Exception as e:
        print(f"Supervisor LLM Error: {e}")
        return Command(goto="END",
                       update={"messages": messages + [AIMessage(content=f"Supervisor failed to route: {e}")]})

    goto = result["next"]
    reasoning = result["reasoning"]

    log = {
        "supervisor": {
            "selected_agent": goto,
            "reasoning": reasoning
        }
    }
    messages.append(AIMessage(content=json.dumps(log)))

    return Command(goto=goto, update={"messages": messages})


def Iterationagent(state: State) -> Command[Literal["Supervisor"]]:
    # ... (Iterationagent logic remains the same)

    messages = state["messages"]
    user_query = state["user_query"]
    print("Iteration Agent: Generating structured plans...")


    try:
        import json
        from colorama import Fore, Style
        import asyncio
        from datetime import datetime
        import json

        # Example user query
        prompt_1 = (
            user_query)

        print(f"user query is : {prompt_1}\n\n")

        # Helper function to log time difference
        def log_time(step_name, start_time, end_time):
            duration = (end_time - start_time).total_seconds()
            print(f"{Fore.MAGENTA}â±ï¸  {step_name} took {duration:.2f} seconds{Style.RESET_ALL}\n")
            return duration

        # Start overall timer
        overall_start = datetime.now()
        print(f"{Fore.YELLOW}ðŸš€ Process started at: {overall_start.strftime('%Y-%m-%d %H:%M:%S')}{Style.RESET_ALL}\n")

        # STEP 1: Understanding User Intent
        print(f"{Fore.CYAN}{'-' * 50}\nðŸŽ¯ STEP 1: Understanding User Intent\n{'-' * 50}{Style.RESET_ALL}")
        start_step1 = datetime.now()
        trip1 = get_structured_trip_details(prompt_1)

        end_step1 = datetime.now()
        print("\nStructured Intent Response:\n")
        print(trip1.model_dump_json(indent=2))
        step1_time = log_time("STEP 1 (Understanding User Intent)", start_step1, end_step1)
        # log_process("STEP 1 - Understanding User Intent", step1_time)

        # STEP 2: Destination + Spots + Hotels
        print(
            f"\n{Fore.CYAN}{'-' * 50}\nðŸ“ STEP 2: Destination + Spots Search + Hotel Search\n{'-' * 50}{Style.RESET_ALL}")
        start_step2 = datetime.now()
        # step2 = run_step2(trip1.model_dump())
        step2 = asyncio.run(run_step2(trip1.model_dump()))
        end_step2 = datetime.now()
        print(json.dumps(step2, indent=2))
        step2_time = log_time("STEP 2 (Destination + Spots + Hotels)", start_step2, end_step2)
        # log_process("STEP 2 - Destination + Spots Search + Hotel Search", step1_time)

        # STEP 3: Distance + Cost Estimation
        print(f"\n{Fore.GREEN}{'-' * 50}\nðŸ›£ï¸ STEP 3: Distance + Cost Estimation\n{'-' * 50}{Style.RESET_ALL}")
        start_step3 = datetime.now()
        step3 = asyncio.run(process_spots(step2))
        end_step3 = datetime.now()
        print(json.dumps(step3, indent=2))
        step3_time = log_time("STEP 3 (Distance + Cost Estimation)", start_step3, end_step3)

        # STEP 3: Bridge Conversion + LLM Formatting
        print(f"\n{Fore.YELLOW}{'-' * 50}\nðŸ§© Bridge: Step 3 â†’ Step 4 Conversion\n{'-' * 50}{Style.RESET_ALL}")
        start_step4 = datetime.now()
        python_output = optimize_day_plan(step2, step3)
        final_itinerary = format_itinerary_with_llm(python_output, prompt_1)
        end_step4 = datetime.now()
        print("\nLLM Formatted Itinerary:\n")
        print(json.dumps(final_itinerary, indent=2))
        step4_time = log_time("STEP 3 to 4 (Itinerary Optimization + LLM Formatting)", start_step4, end_step4)

        # STEP 5â€“6: Weather + Enhancements + Final Itinerary
        print(
            f"\n{Fore.MAGENTA}{'=' * 50}\nðŸŒ¦ï¸ STEP 4 & 5 & STEP 6: Weather âœ“ Final Itinerary âœ“ Enhancements âœ“\n{'=' * 50}{Style.RESET_ALL}"
        )
        start_step5 = datetime.now()
        result = asyncio.run(run_itinerary_pipeline(final_itinerary))

        end_step5 = datetime.now()
        print("\nðŸ“Œ FINAL RESULT:\n")
        print(json.dumps(result, indent=2))
        step5_time = log_time("STEP 5â€“6 (Weather + Final Enhancements)", start_step5, end_step5)

        # END â€” Calculate total duration
        overall_end = datetime.now()
        overall_duration = (overall_end - overall_start).total_seconds()

        print(f"{Fore.GREEN}âœ… DONE! Your trip plan has been successfully generated ðŸ¥³âœ¨{Style.RESET_ALL}")
        print(f"{Fore.CYAN}ðŸ“† Process finished at: {overall_end.strftime('%Y-%m-%d %H:%M:%S')}{Style.RESET_ALL}")
        print(f"{Fore.BLUE}ðŸ•’ TOTAL EXECUTION TIME: {overall_duration:.2f} seconds{Style.RESET_ALL}")

        # Summary of all step durations
        print(f"\n{Fore.WHITE}{'=' * 50}")
        print(f"â±ï¸  Execution Time Summary:")
        print(f"  Step 1: {step1_time:.2f}s")
        print(f"  Step 2: {step2_time:.2f}s")
        print(f"  Step 3: {step3_time:.2f}s")
        print(f"  Step 3-4 convertor: {step4_time:.2f}s")
        print(f"  Step 4-5â€“6: {step5_time:.2f}s")
        print(f"{'-' * 50}")
        print(f"  ðŸ•’ Total Time: {overall_duration:.2f}s")
        print(f"{'=' * 50}{Style.RESET_ALL}")

        log = {
            "Iterationagent": {
                "message": "Successfully generated three structured plans.",
                "status": "success",

            }
        }
        print('*'*50)
        print(f"plans as of now generated{result}")
        print('*' * 50)
        messages.append(AIMessage(content=json.dumps(log)))

        return Command(goto="END", update={"messages": messages, "itinerary_plans": result})

    except Exception as e:
        print(f"Iteration Agent LLM Error: {e}")
        log = {
            "Iterationagent": {
                "message": f"Plan generation failed due to an LLM error: {e}",
                "status": "failure"
            }
        }
        messages.append(AIMessage(content=json.dumps(log)))
        return Command(goto="END", update={"messages": messages, "execution_status": "Plan generation failed."})


class CityExtractionSchema(BaseModel):
    """Structured data for extracting origin and destination cities."""
    origin_city: str = Field(description="The starting city for the bus trip.")
    destination_city: str = Field(description="The destination city for the bus trip.")
def BusBookingAgent(state:State)->Command[Literal["END"]]:

    """
    Handles bus route search using Google Directions API.
    It first uses an LLM call to reliably extract the origin and destination cities
    from the user query, and then uses the extracted data for the search.
    """
    messages = state["messages"]
    user_query = state["user_query"]  # Get the original user query

    print("Bus Booking Agent: Starting LLM extraction for source and destination...")

    # --- 1. LLM CALL TO EXTRACT CITIES ---
    extraction_prompt = f"""
    Analyze the following user query which is intended for a bus booking.
    Strictly extract and return ONLY the starting city (origin) and the ending city (destination).
    Query: "{user_query}"
    """

    try:
        # Use the global LLM initialized with the structured output schema
        llm_extractor = llm.with_structured_output(CityExtractionSchema)
        extraction_result = llm_extractor.invoke(extraction_prompt)

        origin_city = extraction_result.origin_city
        destination_city = extraction_result.destination_city

        print(f"LLM Extraction successful: Origin='{origin_city}', Destination='{destination_city}'")

    except Exception as e:
        # Fallback to the existing simple params if the LLM extraction fails
        print(f"LLM Extraction failed: {e}. Falling back to booking_params.")
        params = state.get("booking_params", {})
        origin_city = params.get('origin')
        destination_city = params.get('destination')

    # --- 2. VALIDATION AND ERROR CHECK ---

    if not all([origin_city, destination_city]):
        log = {"BusBookingAgent": {"status": "failure",
                                   "message": "Missing origin or destination city after extraction."}}
        messages.append(AIMessage(content=json.dumps(log)))
        messages.append(AIMessage(
            content="I need both the departure city and arrival city to search for bus routes. Please clarify your trip details."))
        return Command(goto="END",
                       update={"messages": messages,
                               "execution_status": "Bus search failed due to missing params."})

    print(f"Bus Booking Agent: Searching for bus routes: {origin_city} to {destination_city}...")

    # --- 3. GOOGLE DIRECTIONS API CALL ---
    try:
        # Utilize the helper function provided in the prompt
        # We pass the LLM-extracted (and potentially more accurate) city names
        bus_data = get_bus_routes_json(origin_city, destination_city)
        print("indide lang3",bus_data)

        if "error" in bus_data:
            error_msg = bus_data['error']
            log = {"BusBookingAgent": {"status": "failure", "message": f"Bus search failed: {error_msg}"}}
            messages.append(AIMessage(content=json.dumps(log)))
            messages.append(AIMessage(
                content=f"I couldn't find any bus routes from **{origin_city}** to **{destination_city}**. The search system reported: {error_msg}"))
            return Command(goto="END", update={"messages": messages, "execution_status": "No bus routes found."})

        # --- 4. Process and Structure Results (Limit to top 3 for brevity in chat) ---
        structured_buses = []

        # 5. Log and Update State
        log = {
            "BusBookingAgent": {
                "message": f"Found {len(bus_data)} bus route options. Displaying top {len(structured_buses)}.",
                "status": "success",
                "extracted_origin": origin_city,
                "extracted_destination": destination_city
            }
        }
        messages.append(AIMessage(content=json.dumps(log)))

        # Format a user-friendly message
        bus_list_str = "\n".join([
            f"- **{route['route_id']}** ({route['type']}): {route['total_time']}. First Bus: {route['segments'][0]['name']} from {route['segments'][0]['route'].split(' â†’ ')[0]}"
            for route in structured_buses
        ])

        chat_message = f"ðŸšŒ Here are the top bus route options from **{origin_city}** to **{destination_city}**:\n{bus_list_str}\n\nLet me know if you want details on a specific route!"
        messages.append(AIMessage(content=chat_message))

        return Command(goto="END", update={"messages": messages,
                                           "execution_status": "Bus search complete.","travel_bookings":bus_data})

    except Exception as e:
        print(f"Bus Agent Error: {e}")
        messages.append(
            AIMessage(content=json.dumps({"BusBookingAgent": {"status": "failure", "message": str(e)}})))
        messages.append(AIMessage(
            content="I couldn't complete the bus search. There was an internal error during the transit lookup."))
        return Command(goto="END", update={"messages": messages, "execution_status": "Internal error."})



def AccomodationAgent(state:State)-> Command[Literal["END"]]:
    user_query=state["user_query"]
    messages=state["messages"]
    """
       Specialized agent to find and recommend the best accommodation options.

       Flow:
       1. Extract address from user query using an LLM.
       2. Call the external utility to find hotels.
       3. Update the state object with the structured results.
       4. Return control flow command "END".
       """
    print("\n--- AccommodationAgent STARTED ---")
    user_query = state.get("user_query", "No query provided.")
    extraction_prompt = f"""
        Analyze the following user query which is intended for accommodation booking.
    Strictly extract and return ONLY the primary location or full address for the search.
    If multiple locations are mentioned, return the most prominent one.
    Query: {user_query}
       """
    try:
        response = llm.invoke([SystemMessage(content=extraction_prompt), HumanMessage(content=user_query)])
        acoomdationdetails = response.content
    except Exception as e:
        print(f"General Chat LLM Error: {e}")
        chat_response = "I'm sorry, I'm having trouble with my chat services right now."
    result=find_best_nearby_hotels(acoomdationdetails)
    print(f"result from accomodation agent{result}")
    log = {
        "BusBookingAgent": {
            "message": f"Found Accomodation details for the user query",
            "status": "success",

        }
    }
    messages.append(AIMessage(content=json.dumps(log)))
    return Command(goto="END", update={"messages": messages,
                                       "execution_status": "Bus search complete.","acomdation":result})



def FlightBookingagent(state: State) -> Command[Literal["END"]]:
    """Handles flight search using Amadeus API and structures the output."""
    messages = state["messages"]
    params = state.get("booking_params", {})

    origin_city = params.get('origin')
    destination_city = params.get('destination')
    departure_date = params.get('date')
    adults = params.get('adults', 1)

    print(f"Flight Booking Agent: Searching for flights: {origin_city} to {destination_city} on {departure_date}...")

    if not all([origin_city, destination_city, departure_date]):
        log = {"FlightBookingagent": {"status": "failure", "message": "Missing origin, destination, or date in query."}}
        messages.append(AIMessage(content=json.dumps(log)))
        messages.append(
            AIMessage(content="I need both the departure city, arrival city, and a date to search for flights."))
        return Command(goto="END",
                       update={"messages": messages, "execution_status": "Flight search failed due to missing params."})

    try:
        # 1. Get Token
        token = get_amadeus_token('7ft36WGf3banF9BF1MvojU1NdEirPB6e','jdKIeW9Mt0KXOCTr' )
        if not token: raise Exception("Failed to get Amadeus access token.")

        # 2. Get IATA codes
        origin_iata = get_iata_code_for_city(token, origin_city)
        destination_iata = get_iata_code_for_city(token, destination_city)
        if not (origin_iata and destination_iata): raise Exception("Failed to find IATA codes for the cities.")

        # 3. Search for Flights
        flight_params = {
            'originLocationCode': origin_iata,
            'destinationLocationCode': destination_iata,
            'departureDate': departure_date,
            'adults': adults,
            'currencyCode': 'USD',
            'max': 5  # Request max 5 results
        }

        flight_headers = {'Authorization': f'Bearer {token}'}
        flight_response = requests.get(FLIGHT_SEARCH_URL, headers=flight_headers, params=flight_params)
        flight_response.raise_for_status()
        flight_data = flight_response.json().get('data', [])

        if not flight_data:
            log = {"FlightBookingagent": {"status": "success", "message": "No flights found."}}
            messages.append(AIMessage(content=json.dumps(log)))
            messages.append(AIMessage(
                content=f"I couldn't find any direct flight options from {origin_city} to {destination_city} on {departure_date}."))
            return Command(goto="END", update={"messages": messages, "execution_status": "No flights found."})

        # 4. Process and Structure Results (Top 5)
        structured_flights = []
        for i, offer in enumerate(flight_data[:5]):
            price_usd = float(offer['price']['grandTotal'])
            price_inr = price_usd * USD_TO_INR_RATE

            itinerary = offer['itineraries'][0]
            segments = itinerary['segments']
            first_segment = segments[0]

            # Simple check for directness (only one segment)
            is_direct = len(segments) == 1

            structured_flights.append(FlightOptionSchema(
                id=str(uuid.uuid4()),
                carrier=first_segment['carrierCode'],
                flight_number=f"{first_segment['carrierCode']}{first_segment['number']}",
                departure_time=first_segment['departure']['at'].split('T')[1][:5],
                arrival_time=itinerary['segments'][-1]['arrival']['at'].split('T')[1][:5],
                origin_iata=first_segment['departure']['iataCode'],
                destination_iata=itinerary['segments'][-1]['arrival']['iataCode'],
                duration=itinerary['duration'].replace('PT', ''),  # e.g., '1H15M'
                price_inr=round(price_inr),
                is_direct=is_direct
            ).dict())

        # 5. Log and Update State
        log = {
            "FlightBookingagent": {
                "message": f"Found {len(structured_flights)} flight options.",
                "status": "success"
            }
        }
        messages.append(AIMessage(content=json.dumps(log)))

        # Add a final chat message for the user, describing the action taken
        chat_message = f"Here are the flight options from {origin_city} to {destination_city} on {departure_date} for you. Let me know if you need any further assistance!"
        messages.append(AIMessage(content=chat_message))

        return Command(goto="END", update={"messages": messages, "flight_data": structured_flights,
                                           "execution_status": "Flight search complete."})

    except requests.exceptions.HTTPError as e:
        print(f"API HTTP Error: {e}")
        error_message = f"An API error occurred while searching for flights. Please check the Amadeus API response details."
        messages.append(
            AIMessage(content=json.dumps({"FlightBookingagent": {"status": "failure", "message": error_message}})))
        messages.append(AIMessage(
            content="I'm sorry, I ran into an issue connecting to the flight system. Please check the cities and date format."))
        return Command(goto="END", update={"messages": messages, "execution_status": "API error."})
    except Exception as e:
        print(f"Flight Agent Error: {e}")
        messages.append(AIMessage(content=json.dumps({"FlightBookingagent": {"status": "failure", "message": str(e)}})))
        messages.append(AIMessage(content="I couldn't complete the flight search. Please try rephrasing your request."))
        return Command(goto="END", update={"messages": messages, "execution_status": "Internal error."})



def GeneralChatagent(state: State) -> Command[Literal["END"]]:
    # ... (GeneralChatagent logic remains the same)

    user_query = state["user_query"]
    messages = state["messages"]
    print("General Chat Agent: Generating simple chat response...")

    system_instruction = "You are a friendly and helpful travel AI. Respond concisely to the user's message. Do not generate itineraries or discuss bookings unless prompted. Keep the response short and conversational."

    try:
        response = llm.invoke([SystemMessage(content=system_instruction), HumanMessage(content=user_query)])
        chat_response = response.content
    except Exception as e:
        print(f"General Chat LLM Error: {e}")
        chat_response = "I'm sorry, I'm having trouble with my chat services right now."

    log = {
        "GeneralChatagent": {
            "message": "Chat response generated.",
            "status": "success"
        }
    }
    messages.append(AIMessage(content=json.dumps(log)))
    messages.append(AIMessage(content=chat_response))

    return Command(goto="END", update={"messages": messages, "execution_status": "Chat complete."})


# --- 5. GRAPH DEFINITION AND COMPILATION ---




def compile_graph():
    """Compiles and returns the LangGraph application."""
    graph_builder = StateGraph(State)

    # Add all nodes
    graph_builder.add_node("initialagent", initialagent)
    graph_builder.add_node("Supervisor", Supervisor)
    graph_builder.add_node("FlightBookingagent", FlightBookingagent)
    graph_builder.add_node("Iterationagent", Iterationagent)
    graph_builder.add_node("GeneralChatagent", GeneralChatagent)
    graph_builder.add_node("BusBookingAgent", BusBookingAgent)
    graph_builder.add_node("AccomodationAgent", AccomodationAgent)
    graph_builder.add_node("END", lambda x: x)

    # Define edges
    graph_builder.add_edge(START, "initialagent")
    graph_builder.add_edge("initialagent", "Supervisor")

    graph_builder.add_edge("Iterationagent", "END")
    graph_builder.add_edge("FlightBookingagent", "END")
    graph_builder.add_edge("BusBookingAgent", "END")
    graph_builder.add_edge("GeneralChatagent", "END")
    graph_builder.add_edge("AccomodationAgent", "END")

    # Conditional edge from Supervisor


    return graph_builder.compile()


# Export the compiled graph
langgraph_app = compile_graph()


# if __name__ == '__main__':
#     # This block is for testing the graph logic in isolation if needed
#     print("LangGraph module compiled successfully.")
# query_in_english="help me to book me a hotel near mahaballipuram chennai"
# op=langgraph_app.invoke( {
#             "messages": [HumanMessage(content=query_in_english)],
#             "user_query": query_in_english
#         })
# print(f"langraph op->>>>>>>>>>{op}")
#
# if __name__ == '__main__':
#     # This block is for testing the graph logic in isolation if needed
#     langgraph_app
#     print("LangGraph module compiled successfully.")